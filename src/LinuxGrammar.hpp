#ifndef LINUXGRAMMAR_H
#define LINUXGRAMMAR_H

#include <cstdio>
#include <ctime>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <iostream>

using namespace std;

// filesystem access IO
#include <sys/types.h>
#include <sys/dir.h>
#include <sys/param.h>

// for scandir()
extern int alphasort();

#define MAX_NUM_FILE_LIST 256
#define MAX_NUM_DIR_LIST 256

#include "OS2NN.hpp"
	
	/**
	 * An enumeration of the command keywords useable in the grammar.
	 * May be extended. 
	 */
	typedef enum command{
		BASENAME,
		BC,
		CAL,
		CAT,
		CD,
		CP,
		CUT,
		DATE,
		DIFF,
		DIG,
		DIRNAME,
		DMESG,
		DU,
		ECHO,
		ENV,
		EXPORT,
		FILE_CMD,
		FIND,
		GREP,
		GROUPS,
		HEAD,
		TAIL,
		HISTORY,
		HOSTNAME,
		ID,
		IFCONFIG,
		LN,
		LOCATE,
		LS,
		LSOF,
		MKDIR,
		MV,
		PING,
		PS,
		PWD,
		SCP,
		RM,
		SED,
		SEQ,
		SORT,
		TEE,
		TOUCH,
		UNAME,
		UNIQ,
		USERS,
		WC,
		WHO,
		HPING,
		LAST_COMMAND, //This must ALWAYS be the second last command in the enum. It's value is used to select random commands.
		SPECIAL_COMMAND = -1, //must always be last to avoid counting issues.
	}command;

	/**
 	 * An enumeration of possible I/O requirements for GNU/Linux system commands.
	 */
	typedef enum command_io {
		NOTHING = 0,
		INPUT = 1,
		OUTPUT = 2,
		IP_OP = INPUT + OUTPUT,
		IP_OPT = 4,
		IP_OPT_OP = IP_OPT + OUTPUT,
	} command_io;

/** 
 * Impliments a context-free attribute grammar representing a large
 * range of possible GNU/Linux shell commands. The grammer can be used
 * only for generation tasks, during which a given numeric sequence
 * will be translated into a specific string of the grammar in a semi-
 * deterministic fashion. The grammar also incorporates several uncontentional
 * command forms, which modify a set of state buffers rather than generating 
 * a true command string. These state buffers are used by an associated neural
 * network to generate new numeric sequences.
 * <br/><br/>
 * An additional grammar object must be instantied for each new member of the 
 * Individual class, to avoid the loss of state information. This instantiation
 * occours at the time of construction, and is implict in the construction of the
 * nn2os member of the Individual class. 
 * <br/><br/>
 * The grammar class is largely thread safe, but race conditions can occour over
 * the regeneration of the shared static dictionaries and file path collections.
 * This could be easily solved with proper use of semaphores, or by increasing 
 * memory requirements and making the variables non-static.
 * 
 * @see Individual.hpp
 * @see NN2OS.hpp
 * @see OS2NN.hpp
 * @Author: John Doucette
 * @Date: June 28th, 2010
 * 
*/
class LinuxGrammar{

public:
	/** 
	 * @param opsize	The expected size of a numerical input to the grammar for generation.
	 * @param nbuf 		The number of buffers stored in system memory in the OS2NN object bufs.
	 * @param threashold	The minimum neural network output value which should be interpreted as "activated".
				Used during generation as the part of the interpretation of output values.
	 * @param bufs		A pointer to the buffer storage object for this individual.
	*/
	LinuxGrammar(unsigned long opsize, int nbuf, double threashold, OS2NN *bufs);
	~LinuxGrammar();

	/**
	 * This is the Starting non-terminal symbol for the grammar. As such, it is the only
	 * symbol which should be called from outside this module.
	 * @param nnop	A pointer to an array of double values of size opsize.
	 * @return The return value indicates the outcome of the generation attempt.
	 *	   If the input generates a semantically or syntatically invalid string, -1 is returned.
	 *	   <br/>	
	 *	   If the input indicates writing to a buffer should occour instead of generation, 0 is returned.
	 * 	   <br/>
	 *	   If the input caused generation of a valid command string, a summary code in range 1-127 is returned.
	 */
	int S(char *dstbuf, double* nnop);

	
	/**
	 * The string representation of each command's name
	 */
	static const char *command_names[];
	
	/**
	 * An indiaction of the I/O requirements for each command.
	 */	
	static const command_io command_ios[];

	/**
	 * Summary values for each valid command's behavior. When more than one command
	 * is present at once (as in a pipe opperation), the values are combined using bitwise OR.
	 */	
	static const unsigned long command_types[];

	/**
	 *A list of the valid flags for each command.
	 */	
	static const char *command_flags[];

	/**
	 * A list of command line arguments which are <b>required</b> for each, in the order they are needed. 
	 */	
	static const char *required_clargs[];

	/**
	 * A list of <b>optional</b> command line arguments for each command, in no particular order. 
	 * Optional arguments always follow required ones on the command line in string generated by 
	 * this grammar.
	 */	
	static const char *optional_clargs[];

	/**
	 * The current working directory of the coresponding Individual. Used when picking file names, etc.
	 * in the grammar.
	 */	
	char cwd[BUFSIZ];

	/**
	 * Regenerates the list of files (both directory and non-directory) in the current directory.
	 * Called by the starting non-terminal before generation begins.
	 */
	int update_file_dir_list(void);

	/**
	 * Helper method to execute the command pointed to by cmd and return the line number specified by n
	 */
	static char *exec_and_return_line( const char *cmd, int n );

	/**
	 * The number of files in the current directory. Behavior is non-standard when this is zero.
	 */
	int num_files;
	/**
	 * The number of folders (directories)  in the current directory. Behavior is non-standard when this is zero.
	 */
	int num_dirs;

protected: 
	
	/**
	 * The expected size of a numerical input sequence to the grammar during generation.
	 * Should match the number of output neurons used by the Individual class.
	 * @see Individual.cpp
	*/
	unsigned long nnop_size;
	
	/**
	 * The number of buffers the Individual has access to.
	*/
	int num_bufs;

	/**
	 * A counter that tracks how much of the input sequence has been consumed. If it exceeds the
	 * size of the sequence (nnop_size), then it's value is used modulo nnop_size.
	 * The counter is reset to 0 by the starting non-terminal of the grammar prior to generation.
	*/
	int where_in_nnop;

	/**
	 * The minimum value in a numerical input sequence that will be interpreted as a boolean true.
	 * This should match the value set in the NN2OS object which acts as a parent to this instance
	 * of LinuxGrammar.
	*/
	double threashold;

	/**
	 * The buffer used by the grammar during runtime.
	 * It is only a pointer to the actual memory location and after setting should only be accessed for writing using the buf_append method.
	*/
	char *mbuf;

	/**
	 * The buffer used by the grammar during generation.
	 * It is allocated in buf_init.
	*/
	char *mbuf_orig;

	/**
	 * The size of the main buffer.
	 *
	 * @see mbuf
	 */
	unsigned long mbuf_length;

	/**
	 * The original size of the "main main" buffer mbuf_orig.
	 *
	 * @see mbuf
	 */
	unsigned long mbuf_length_orig;

	/**
	 * Internal pointer to current writing location of our current main buffer.
	 *
	 * @see mbuf
	 */
	unsigned long mbuf_pos;

	/**
	 * Internal pointer to current writing location of our "main main" buffer mbuf_orig.
	 *
	 * @see mbuf
	 */
	unsigned long mbuf_pos_orig;

	/**
	* A pointer to the buffer management object for the Individual associated with this instance
	* of the grammar. 
	*/
	OS2NN *bufs;

	/**
	 * A list of the non-directory files in the current working directory of the 
	 * Individual associated with this instance of LinuxGrammar. If more than
	 * MAX_NUM_FILE_LIST files are present, only the lexicographically first
	 * MAX_NUM_FILE_LIST of them will appear in this list.
	*/
	char *file_list[MAX_NUM_FILE_LIST];

	/**
	 * A list of the directory files in the current working directory of the 
	 * Individual associated with this instance of LinuxGrammar. If more than
	 * MAX_NUM_FILE_LIST files are present, only the lexicographically first
	 * MAX_NUM_FILE_LIST of them will appear in this list.
	*/
	char *dir_list[MAX_NUM_DIR_LIST];

	/**
	 * A list of valid url suffixes, e.g. com, ca, org, edu, etc.
	 * Declared in static memory in LinuxGrammar.cpp
	*/
	static const char *url_suffixes[];

	/**
	 * The number of known top-level domains.
	*/
	int num_tlds;

	/**
	 * A counter used to store the bitwise-OR combined summary values for 
	 * all commands used during a single attempt at generation.
	*/
	unsigned long accumulate;
	

////////////////////////////////////////////////////////////////////////////////
	
	/**
	* Terminal symbol: A random word from the system dictionary
	* @param nnop An array of doubles used as the numeric input sequence to the grammar.
	* @return -1 	if the size of buf exceeds BUFSIZ after appending a random word, 0
	* 		otherwise.
	*/
	int random_word(double *nnop);

	/**
	* Terminal symbol: A word from the system dictionary refered to by the next value
	*		   in the numeric sequence used in this generation attempt. 
	*		   The exact word is determined using linearization.
	* @param nnop An array of doubles used as the numeric input sequence to the grammar.
	* @return -1 	if the size of buf exceeds BUFSIZ after appending the word, 0
	* 		otherwise.
	*/
	int da_word(double *nnop);

	/**
	* Terminal symbol: A random number from  0 to 1.
	* @param nnop An array of doubles used as the numeric input sequence to the grammar.
	* @return -1 	if the size of buf exceeds BUFSIZ after appending the number, 0
	* 		otherwise.
	*/
	int random_number(double *nnop);

	/**
	* Terminal symbol: A random number in a particular range. Used by several other 
			symbols of the grammar to produce contrained random tokens.
	* @param nnop 	An array of doubles used as the numeric input sequence to the grammar.
	* @param top 	The maximum value which should be produced.
	* @param bottom	The minimum value which should be produced.
	* @param ints_only	0 if real-valued numbers are required, otherwise only ints
				will be produced.
	* @return -1 	if the size of buf exceeds BUFSIZ after appending the number, 0
	* 		otherwise.
	*/
	int random_number_range(double *nnop, double top, double bottom, int ints_only);

	/**
	* Terminal symbol: A number produced via linearization of the next element of
			the input numeric sequence.
	* @param nnop An array of doubles used as the numeric input sequence to the grammar.
	* @return -1 	if the size of buf exceeds BUFSIZ after appending the number, 0
	* 		otherwise.
	*/
	int number(double *nnop, int intsonly);
	
	/**
	* Non-Terminal symbol: Appends a random IPv4 address to the input buffer, by
	*			producing the correct sequence of terminal symbols.
	*			Relies on the random_number_range non-terminal.
	* @param nnop An array of doubles used as the numeric input sequence to the grammar.
	* @return -1 	if the size of buf exceeds BUFSIZ after appending the ip, 0
	* 		otherwise.
	*/
	int ip_address(double *nnop);

	/**
	* Non-Terminal symbol: Appends a random URL address to the input buffer, by
	*			producing the correct sequence of terminal symbols.
	*			relies on random_word and url_suffixes termal symbols.
	* @param nnop An array of doubles used as the numeric input sequence to the grammar.
	* @return -1 	if the size of buf exceeds BUFSIZ after appending the URL, 0
	* 		otherwise.
	*/
	int URL(double *nnop);
	
	/**
	* Terminal symbol: Appends a single char to the input buffer, selected via 
	 *		linearization of the next element of the input sequence.
	* @param nnop An array of doubles used as the numeric input sequence to the grammar.
	* @return -1 	if the size of buf exceeds BUFSIZ after appending the char, 0
	* 		otherwise.
	*/
	int getchar(double *nnop);

	/**
	* Terminal symbol: Appends a non-directory file name to the input buffer,
	*		 selected via linearization of the next element of the input sequence.
	* @param nnop An array of doubles used as the numeric input sequence to the grammar.
	* @return -1 	if the size of buf exceeds BUFSIZ after appending the filename, 0
	* 		otherwise.
	*/
	int fname(double *nnop);
	
	/**
	* Get an stored buffer for the associated Individual via linearization of the
	* input sequence. 
	* @param nnop	An array of doubles used as the numeric input sequence to the grammar.
	* @return	The index of the buffer to be used.
	*/
	int buff_num(double *nnop);

	/**
	* Determine whether a buffer will be appended or overwritten via linearization 
	* of the input sequence. 
	* @param nnop	An array of doubles used as the numeric input sequence to the grammar.
	* @return	1 if the buffer will be overwritten, 0 otherwise.
	*/
	int write_mode(double *nnop);

////////////////////////////////////////////////////////////////////////////////////////

	/**
	 * Non-Terminal Symbol: Either appends the contents of one of the buffers 
	 * 	belonging to the associated Individual, or a string of selected
	 *	non-terminals using the gen_words symbol.
	 * @param nnop An array of doubles used as the numeric input sequence to the grammar.
	 * @return -1 	if the size of buf exceeds BUFSIZ after appending the various
	 *		terminal symbols, 0 otherwise.
	*/
	int iptype(double *nnop);
	
	/**
	 * Non-Terminal Symbol: Recursivly appends non-terminal symbols selected
	 * 	using linearization of the input sequence.
	 * @param nnop An array of doubles used as the numeric input sequence to the grammar.
	 * @return -1 	if the size of buf exceeds BUFSIZ after appending the various
	 *		terminal symbols, 0 otherwise.
	*/
	int gen_words(double *nnop);

	//cmd is replaced by one of 8 different options, allowing commands to be chained it 
	/**
	 * Non-Terminal Symbol: Recursivly constructs the syntatic format of the 
	 * 	command string, using three attributes to determine possible valid
	 * 	expansion of itself at each step, and picking between them using
	 *	the linearization of the input sequence taken modulo 9.
	 * @param nnop An array of doubles used as the numeric input sequence to the grammar.
	 * @param ip_used	An attribute of the grammar. If true, it indicates that
				the current instance of command must resolve to a form
				which accepts stdin data, and which may not accept additional
				sources of input. If this becomes impossible to produce,
				the grammar will reject the input sequence as semantically
				invalid.
	 * @param op_used	An attribute of the grammar. If true, it indicates that
				the current instance of command must resolve to a form
				which produces stdout data, and which may not bind to additional
				output destinations. If this becomes impossible to produce,
				the grammar will reject the input sequence as semantically
				invalid.
	 * @param err_used	An attribute of the grammar. If true, it indicates that
				the current instance of command must resolve to a form
				which produces stderr data, and which may not bind to additional
				error destinations. If this becomes impossible to produce,
				the grammar will reject the input sequence as semantically
				invalid.
	 * @return -1 	if the size of buf exceeds BUFSIZ after full expansion of the non-
	 *		terminal symbols, 0 otherwise.
	*/
	int cmd(double *nnop, int ip_used, int op_used, int err_used);

	/**
	 * Terminal Symbol: Appends a valid system path to the buffer. Selected via
	 *		linearization.
	 * @param nnop An array of doubles used as the numeric input sequence to the grammar.
	 * @return -1 	if the size of buf exceeds BUFSIZ after appending the 
	 *		terminal symbols, 0 otherwise.
	 * 
	*/
	int path(double *nnop, char what );

	/**
	 * Terminal Symbol: Appends the name of a directory in the current working 
	 * 	directory to the buffer, selected via linearization. If no such
	 *	directory exists, appends "..". 
	 * @param nnop An array of doubles used as the numeric input sequence to the grammar.
	 * @return -1 	if the size of buf exceeds BUFSIZ after appending the 
	 *		terminal symbols, 0 otherwise.
	 * 
	*/
	int directory(double *nnop);

	
	
	/**
	 * Non-Terminal Symbol: Uses linearization to append a command name from the 
	 * 	volcabulary of possible names. If the selected name does not meet the
	 *	constraints imposed by the three attributes attatched to this method,
	 *	then the entire command string is deemed semantically invalid,  and
	 *	a return value of -1 is allowed to cascade throughout the grammar.
	 * @param nnop An array of doubles used as the numeric input sequence to the grammar.
	 * @param ip_used	An attribute of the grammar. If true, it indicates that
	 *			the selected command must accept stdin data, 
	 * @param op_used	An attribute of the grammar. If true, it indicates that
	 *			the selected command must produce stdout data, 
	 * @param err_used	An attribute of the grammar. Not used in this method.
	 * @return -1 	if the size of buf exceeds BUFSIZ after appending the 
	 *		terminal symbols, 0 otherwise.
	*/
	command cname(double *nnop, int ip_used, int op_used, int err_used);

	/**
	 * Non-Terminal Symbol: Uses linearization to append command flags from the 
	 * 	volcabulary for the chosen name. 
	 * @param nnop An array of doubles used as the numeric input sequence to the grammar.
	 * @param cnam 	The index of the chosen command in the volcabulary of the grammar.
	 * @param ip_used	An attribute of the grammar. If true, it indicates that
	 *			the selected command will receive input data, and that
	 *			flags should be added appropreately.
	 * @param op_used	An attribute of the grammar. If true, it indicates that
	 *			the selected command must produce output data, and that
	 *			flags should be added appropreately.
	 * @param err_used	An attribute of the grammar. Not used in this method.
	 * @return -1 	if the size of buf exceeds BUFSIZ after appending the 
	 *		terminal symbols, 0 otherwise.
	*/
	int flags(double *nnop, command cnum, int ip_used, int op_used, int err_used);

	/**
	 * Non-Terminal Symbol: Uses linearization to append optional command line
	 *	arguments from the volcabulary for the chosen name. Required command
	 *	line arguments are also added.
	 * @param nnop An array of doubles used as the numeric input sequence to the grammar.
	 * @param cnam 	The index of the chosen command in the volcabulary of the grammar.
	 * @param ip_used	An attribute of the grammar. If true, it indicates that
	 *			the selected command will receive input data, and that
	 *			clargs should be added appropreately.
	 * @param op_used	An attribute of the grammar. If true, it indicates that
	 *			the selected command must produce output data, and that
	 *			clargs should be added appropreately.
	 * @param err_used	An attribute of the grammar. Not used in this method.
	 * @return -1 	if the size of buf exceeds BUFSIZ after appending the 
	 *		terminal symbols, 0 otherwise.
	*/
	int clargs(double *nnop, command cnum, int ip_used, int op_used, int err_used);

	/**
	 * Returns the next element in the numeric sequence used as input during generation
	 * in the grammar.
	 * @param nnop	An array of doubles used as the numeric input sequence to the grammar.
	 * @return 	The value of the next element in the sequence, proceeding circularly.
	*/
	double next_nnop(double *nnop);

	/**
	 * Performs linearization in the grammar. Input data is assumed to be the result of 
	 * a Gaussian function, and this inverted to give the input value of that function.
	 * Uses numeric constants defined in nn/nn.h
	 * @param y	A double value taken from a gaussian function's output.
	 * @return 	The absolute value of the input to the gaussian function which produced y.
	*/
	double linearize(double y);


	/**
	 * Initializes the main buffer of this class to the given size.
	 *
	 * @return -1 if the buffer could not be initialized, 0 otherwise.
	 */
	int buf_init( unsigned long size );

	/**
	 * Clears the main buffer of this class.
	 *
	 * @return -1 if the buffer could not be cleared, 0 otherwise.
	 */
	int buf_clear();

	/**
	 * Temporarily sets the main buffer to something else.
	 *
	 * @param	tb		A pointer to the buffer to use temporarily or NULL if original buffer should be restored.
	 * @param	size	The size of the temporary buffer, ignored if restoring the original buffer.
	 *
	 *
	 */
	void buf_set( char *tb, unsigned long size );

	/**
	 * Appends data of given length to the main buffer.
	 *
	 * @param	data	A pointer to the data to be appended.
	 * @param	size	The length of the data to be appended in bytes.
	 *
	 * @return -1 if the data could not be appended to the main buffer, possibly due to insufficent space, 0 otherwise.
	 */
	int buf_append( const char *data, unsigned long size );

};


#endif
  
